#' Function for visualizing trajectories generated by ZPDGrowthTrajectories
#'
#' \code{visualizeTrajectories} plots synthetic growth trajectories using \code{ggplot2}.
#'
#' \code{visualizeTrajectories} plots the trajectories generated by the \code{ZPDGrowthTrajectories()}
#'  function. The figure plots achievement versus time and represents each student's trajectory using a
#'  different colored line.
#'
#' @param trajectories An object of class \code{ZPD} produced by the \code{ZPDGrowthTrajectories()}
#'  function. If needed, this object be converted internally to "long" format suitable for
#'  \code{ggplot}.The function returns a \code{ggplot} object that can be modified with typical
#'  \code{ggplot2} arguments.
#'
#' @param showTransitions Logical. Should vertical lines be drawn when the school curriculum changes?
#'   Defaults to FALSE
#'
#' @param timerange Optional numeric vector providing limits for the x axis. Defaults to NULL.
#'
#' @family visualizations
#'
#' @seealso \code{\link{describeTrajectories}} for calculating summary statistics of the generated
#'  trajectories.
#'
#' @seealso \code{\link{ZPDGrowthTrajectories}} for simulating growth trajectories.
#'
#' @importFrom utils tail
#'
#' @export

  visualizeTrajectories <- function(trajectories, showTransitions=FALSE, timerange=NULL) {

  # check if trajectories is class ZPD, if not stop
  if(!("ZPD" %in% class(trajectories))) {stop("Object supplied to trajectories argument is not ZPDGrowthTrajectories() output")}

  # check if showTransitions is logical

  if(checkmate::qtest(showTransitions, "B1")==FALSE) {stop("showTransitions must be TRUE or FALSE")}


  if (is.null(timerange)==FALSE) {
    if(checkmate::qtest(timerange, "N2[0,)")==FALSE) {stop("timerange must either be NULL or a nonnegative vector of length 2")}
    if (any(timerange > max(trajectories$time))) {stop("a value in timerange exceeds the range of time points included in trajectories")}
    if (timerange[2] <= timerange[1]) {stop("values supplied to timerange must be in ascending order")}
  }


  # check to see if the trajectories are in long or wide format
  # if long, it will have 9 columns
  # if wide format, flip to long

  if (ncol(trajectories) != 9) {
    nstudents <- nrow(trajectories)
    times <- ncol(trajectories)-6

    trajectories <- reshape2::melt(trajectories, id.vars=1:6)
    trajectories[,7] <- rep(seq(1:times), each=nstudents)
    names(trajectories) <- c("id", "learn.rate", "home.env", "decay.rate", "initial.ach",
                             "curriculum", "time", "achievement")
    trajectories <- trajectories[order(trajectories$id),]
  }

  if (!is.null(timerange)) {

    p <- ggplot2::ggplot(data=trajectories[trajectories$time >= timerange[1] & trajectories$time <= timerange[2],],
                         ggplot2::aes(x=time, y=achievement, color=factor(id)))+
      ggplot2::geom_line(show.legend=FALSE, size=.5, alpha=.5) +
      ggplot2::geom_hline(yintercept=0, col="gray")+ggplot2::geom_vline(xintercept=0, col="gray")+
      ggplot2::theme(panel.background=ggplot2::element_blank(), panel.grid.major=ggplot2::element_blank(),
                   panel.grid.minor=ggplot2::element_blank())
  } else {

    p <- ggplot2::ggplot(data=trajectories, ggplot2::aes(x=time, y=achievement, color=factor(id)))+
      ggplot2::geom_line(show.legend=FALSE, size=.5, alpha=.5) +
      ggplot2::geom_hline(yintercept=0, col="gray")+ggplot2::geom_vline(xintercept=0, col="gray")+
      ggplot2::theme(panel.background=ggplot2::element_blank(), panel.grid.major=ggplot2::element_blank(),
                     panel.grid.minor=ggplot2::element_blank())
  }

  if (showTransitions==TRUE) {

    # get assignment object from ZPDGrowthTrajectories output
    assignment <- trajectories$assignment[trajectories$version==1 & trajectories$id==1]

    # find transitions in the assignment object
    lag.assignment <- c(utils::tail(assignment,-1),NA)

    # index of those transitions, appending first and last time point / time
    index <- which(assignment != lag.assignment)

    p <- p + ggplot2::geom_vline(xintercept=index, alpha=.25)
  }

  if (!is.null(timerange)) {
    p <- p + ggplot2::coord_cartesian(xlim=timerange)
  }

  return(p)
}
